# 종합 디버깅 및 아키텍처 분석 보고서 (재작성)

## 1. 개요

이 문서는 RAGTrace 프로젝트의 초기 아키텍처를 분석하고, 식별된 문제점을 해결하기 위해 적용된 클린 아키텍처 기반의 개선안을 설명합니다. 초기 버전은 기능적으로는 동작했지만, 유지보수성과 확장성 측면에서 구조적인 문제들을 내포하고 있었습니다. 본 보고서는 이러한 문제들을 어떻게 해결하고 시스템을 더 견고하게 만들었는지에 대해 기술합니다.

---

## 2. 초기 아키텍처의 문제점 진단

초기 코드베이스는 다음과 같은 주요 문제점을 가지고 있었습니다.

-   **책임의 불명확성**: `run_evaluation`과 같은 핵심 함수가 데이터 로딩, LLM 호출, 평가 실행, 결과 출력 등 너무 많은 책임을 한 번에 수행하고 있었습니다. 이는 SRP(단일 책임 원칙)에 위배되어 코드 변경 시 예상치 못한 부수 효과를 유발할 가능성이 높았습니다.
-   **강한 결합(Tight Coupling)**: 유스케이스 로직이 `GeminiAdapter`나 특정 파일 경로와 같은 구체적인 구현에 직접 의존하고 있었습니다. 이로 인해 LLM을 다른 모델로 교체하거나 데이터 소스를 변경하는 작업이 매우 복잡하고 어려웠습니다.
-   **DI 컨테이너의 부재**: 의존성 주입이 체계적으로 관리되지 않아, 각 컴포넌트가 필요한 의존성을 스스로 생성하거나 전역적으로 접근해야 했습니다. 이는 테스트를 어렵게 만들고 전체 시스템의 유연성을 저해했습니다.

---

## 3. 해결 방안: 클린 아키텍처의 도입

위 문제들을 해결하기 위해, 프로젝트는 **클린 아키텍처(Clean Architecture)**와 **SOLID 원칙**에 기반하여 대대적으로 리팩토링되었습니다.

### 3.1. 의존성 역전 원칙 (DIP) 적용

-   **Ports & Adapters**: `application` 계층에 `LlmPort`, `EvaluationRepositoryPort`와 같은 추상적인 **포트(Port)**를 정의했습니다. 실제 외부 시스템과의 연동을 담당하는 `GeminiAdapter`, `FileRepository` 등은 이 포트를 구현하는 **어댑터(Adapter)**로 분리되었습니다.
-   **효과**: 이제 `RunEvaluationUseCase`와 같은 상위 레벨 정책은 `LlmPort`라는 추상화에만 의존하며, `GeminiAdapter`라는 구체적인 구현에는 의존하지 않습니다. 덕분에 Gemini가 아닌 다른 LLM으로 교체해야 할 경우, 새로운 어댑터만 구현하고 `Container`에서 교체해주면 되므로, 유스케이스 코드는 전혀 수정할 필요가 없습니다.

### 3.2. 단일 책임 원칙 (SRP) 및 팩토리 패턴 적용

-   **책임의 분리**:
    -   **Container**: `src/container.py`의 `Container`는 이제 애플리케이션 전체의 의존성을 생성하고 연결(wiring)하는 단일 책임을 가집니다.
    -   **Use Case**: `RunEvaluationUseCase`는 비즈니스 로직의 흐름(데이터 로드 -> 답변 생성 -> 평가)을 조율(Orchestration)하는 책임만 남게 되었습니다.
    -   **Factories**: `RagasEvalAdapterFactory`와 `FileRepositoryFactory`를 도입하여, 특정 조건(프롬프트 타입, 데이터셋 이름)에 따라 적절한 어댑터 인스턴스를 생성하는 복잡한 로직을 유스케이스와 컨테이너로부터 분리했습니다. 이는 유스케이스를 더 간결하게 유지하고 객체 생성의 책임을 명확히 위임하는 효과적인 방법입니다.

### 3.3. 개선된 아키텍처 흐름

리팩토링 이후, 애플리케이션의 제어 흐름은 다음과 같이 명확해졌습니다.

1.  **애플리케이션 시작**: `main` 함수에서 `Container`를 통해 `RunEvaluationUseCase` 인스턴스를 가져옵니다.
2.  **유스케이스 실행**: `UseCase.execute()`가 호출됩니다.
3.  **의존성 생성**: 유스케이스는 `repository_factory`와 `evaluation_runner_factory`를 사용하여 현재 실행에 필요한 `Repository`와 `EvaluationRunner` 어댑터 인스턴스를 동적으로 생성합니다.
4.  **비즈니스 로직 수행**: 유스케이스는 생성된 어댑터들(Ports)을 통해 외부 시스템과 상호작용하며 핵심 비즈니스 로직을 순서대로 실행합니다.
5.  **결과 반환**: 최종 결과를 도메인 엔티티(`EvaluationResult`)로 변환하여 반환합니다.

## 4. 결론

리팩토링을 통해 RAGTrace 프로젝트는 다음과 같은 이점을 얻었습니다.

-   **유연성 및 확장성**: 새로운 기능 추가나 기술 교체가 용이해졌습니다.
-   **테스트 용이성**: 각 컴포넌트가 분리되고 추상화에 의존하게 되어, 단위 테스트 및 통합 테스트 작성이 훨씬 수월해졌습니다.
-   **유지보수성**: 코드의 책임 소재가 명확해져, 버그를 수정하거나 로직을 변경할 때 영향을 받는 범위를 쉽게 파악할 수 있습니다.

현재 아키텍처는 기술적 부채를 해결하고, 향후 더 복잡한 기능을 수용할 수 있는 견고한 토대를 마련했습니다. 