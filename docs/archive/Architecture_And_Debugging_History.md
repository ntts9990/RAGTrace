# RAGTrace 아키텍처 및 디버깅 변천사

이 문서는 RAGTrace 프로젝트의 아키텍처가 어떻게 발전해왔는지, 그리고 그 과정에서 어떤 문제들이 있었고 어떻게 해결되었는지를 기록한 종합적인 역사 기록물입니다.

---

## 1장: 초기 아키텍처의 도전과 클린 아키텍처로의 전환

### 1.1. 초기 아키텍처의 문제점

프로젝트 초기 코드베이스는 다음과 같은 주요 문제점을 가지고 있었습니다.

-   **책임의 불명확성**: `run_evaluation`과 같은 핵심 함수가 데이터 로딩, LLM 호출, 평가 실행, 결과 출력 등 너무 많은 책임을 한 번에 수행하고 있었습니다. 이는 SRP(단일 책임 원칙)에 위배되어 코드 변경 시 예상치 못한 부수 효과를 유발할 가능성이 높았습니다.
-   **강한 결합(Tight Coupling)**: 유스케이스 로직이 `GeminiAdapter`나 특정 파일 경로와 같은 구체적인 구현에 직접 의존하고 있었습니다. 이로 인해 LLM을 다른 모델로 교체하거나 데이터 소스를 변경하는 작업이 매우 복잡하고 어려웠습니다.
-   **DI 컨테이너의 부재**: 의존성 주입이 체계적으로 관리되지 않아, 각 컴포넌트가 필요한 의존성을 스스로 생성하거나 전역적으로 접근해야 했습니다. 이는 테스트를 어렵게 만들고 전체 시스템의 유연성을 저해했습니다.

### 1.2. 해결 방안: 클린 아키텍처의 도입

위 문제들을 해결하기 위해, 프로젝트는 **클린 아키텍처(Clean Architecture)**와 **SOLID 원칙**에 기반하여 대대적으로 리팩토링되었습니다.

-   **의존성 역전 원칙 (DIP) 적용**: `application` 계층에 `LlmPort`, `EvaluationRepositoryPort`와 같은 추상적인 **포트(Port)**를 정의하고, 실제 외부 시스템 연동은 이 포트를 구현하는 **어댑터(Adapter)**로 분리했습니다.
-   **단일 책임 원칙 (SRP) 및 팩토리 패턴 적용**: 의존성 주입을 위한 `Container`, 비즈니스 흐름을 조율하는 `Use Case`, 동적 객체 생성을 위한 `Factory` 등으로 책임을 명확히 분리했습니다.

이러한 리팩토링을 통해 **유연성, 확장성, 테스트 용이성, 유지보수성**이 크게 향상되었고, 기술적 부채를 해결하여 향후 더 복잡한 기능을 수용할 수 있는 견고한 토대를 마련했습니다.

---

## 2장: 아키텍처 성숙 단계와 최종 제안 (구 v3 보고서)

### 2.1. 개요

이 장은 v2 보고서 이후 대대적으로 개선된 RAGTrace 프로젝트의 최신 소스 코드를 심층 분석한 결과를 담고 있습니다. 이번 분석에서는 이전 보고서들에서 제안된 개선 사항들의 이행 상태를 확인하고, 현재 아키텍처의 완성도를 평가하며, 한 단계 더 나아가기 위한 구체적인 제안을 제공하는 데 중점을 둡니다.

**분석 결과 요약:**
프로젝트는 **놀라울 정도로 발전**했습니다. 아키텍처의 구조적 안정성을 확보한 것을 넘어, **사용자 경험(UX)과 시스템의 견고성(Robustness)을 고려한 실용적인 기능들이 대거 추가**되었습니다. 현재 RAGTrace는 단순한 평가 도구를 넘어, 신뢰성 있는 피드백을 제공하는 성숙한 플랫폼으로 진화하고 있습니다.

### 2.2. 아키텍처 현황 분석: 성숙 단계에 진입한 시스템

#### 완결된 개선 사항: 제안에서 현실로

이전 v2 보고서 및 사용자 시나리오 분석에서 제안되었던 핵심 개선 사항들이 성공적으로 구현되었습니다.

-   **데이터 사전 검증 (Pre-flight Check)**: `DataContentValidator` 도입으로 "Garbage In, Garbage Out" 문제를 근본적으로 방지합니다.
-   **API 장애에 대한 방어적 설계**: 개별 답변 생성 실패를 집계하여 결과의 신뢰도를 판단할 객관적인 근거를 제공합니다.
-   **견고한 도메인 모델**: `EvaluationResult`가 자체 비즈니스 로직을 포함하는 리치 도메인 모델로 발전했습니다.
-   **안정적인 아키텍처 기반**: '상태 없는 컨테이너', '팩토리 패턴', '명확한 유스케이스 책임 분리' 등의 견고한 아키텍처가 유지됩니다.

#### 최종 완성도를 위한 추가 개선 제안

현재 시스템은 매우 훌륭하지만, 최고 수준의 완성도를 위해 몇 가지 추가적인 리팩토링 및 개선 포인트를 제안합니다.

-   **[제안 1] 유스케이스의 비대화(Bloated Use Case) 방지**: `GenerationService`와 `ResultConversionService`를 추가로 도입하여 `RunEvaluationUseCase`의 책임을 분리하고 복잡도를 낮출 것을 제안합니다.
-   **[제안 2] 대용량 처리를 위한 비동기 아키텍처 도입 준비**: `async/await`으로 점진적 전환 및 `Celery`와 같은 태스크 큐 도입을 장기적인 목표로 고려할 수 있습니다.

### 2.3. 종합 결론 및 최종 권장 사항

RAGTrace 프로젝트는 이제 **기술적 견고함과 실용적 가치를 모두 갖춘 성숙한 애플리케이션**의 단계에 도달했습니다.

**최종 권장 사항:**
1.  **유스케이스 리팩토링**: `GenerationService`와 `ResultConversionService`를 도입하여 유스케이스의 복잡도를 낮추는 작업을 진행하는 것을 강력히 권장합니다.
2.  **비동기 처리 도입 고려**: 대규모 평가로 확장할 계획이 있다면 다음 메이저 업데이트 목표로 비동기 처리 도입을 설정하는 것이 바람직합니다.
3.  **문서화 및 테스트**: 안정화된 아키텍처에 맞춰 문서를 최신화하고, 추가된 서비스에 대한 단위 테스트를 보강하여 높은 코드 품질을 유지해야 합니다.

---

## 부록: 특정 시점의 상세 디버깅 리포트

### 개요

이 부록은 과거 특정 시점의 `pytest` 테스트 스위트에서 발견된 8개의 실패 항목에 대한 상세 분석 및 해결 방안을 담고 있습니다.

### 핵심 기능 장애 분석 및 해결 방안

#### A.1. 의존성 주입 컨테이너(`Container`) 기능 장애

-   **문제 1: 유스케이스 생성 불가 (`AttributeError`)**: `get_evaluation_use_case` 메서드가 존재하지 않았음. -> **해결**: 메서드 추가 구현.
-   **문제 2: 잘못된 Mocking 전략 (`AssertionError`)**: `patch`의 대상 경로가 잘못 지정되었음. -> **해결**: patch 대상을 "사용되는 위치" 기준으로 수정.
-   **문제 3: 불일치하는 예외 메시지 (`AssertionError`)**: 테스트 코드의 기대 메시지와 실제 발생 메시지가 달랐음. -> **해결**: 기대 메시지를 실제 메시지로 수정.

#### A.2. 웹 대시보드 컴포넌트 기능 장애

-   **문제 1: 상세 분석 페이지 오류 (`NameError`)**: 불필요한 코드 라인으로 인한 에러. -> **해결**: 해당 라인 삭제.
-   **문제 2: 성능 모니터링 페이지 오류 (`AssertionError`)**: 실제 데이터 로직과 다른 부분을 모킹함. -> **해결**: `pandas.read_sql_query`를 직접 모킹하도록 수정.
-   **문제 3: 메인 대시보드 페이지 오류 (`AssertionError`)**: 부동소수점 연산 오차로 인한 비교 실패. -> **해결**: `pytest.approx`를 사용하여 근사치 비교로 수정. 